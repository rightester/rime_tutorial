# Rime、YAML、正则表达式

本篇主要讲Rime与**YAML配置文件**与**预编译指令**，和Rime与**正则表达式**与**拼写运算**；这些都是一些计算机界通用技术，由Rime利用并提出了一些自己的DSL领域语言，或者简单来说Rime使用这些基本技术并在其之上拓展了一些能力，也需要你掌握新语法和约定等；对于纯外行，你需要先大致了解通用基础部分，然后再继续了解Rime的拓展部分

## YAML

YAML是一种配置文件的格式；

常用于配置文件的格式除了YAML还有TOML、JSON、XML；

> YAML与其他配置文件格式对比，有一条潜在优势是该标准允许使用包括中文字符在内的更多字符作为裸键，比较简洁；JSON的键一定要加双引号表明是字符串、TOML则是“**裸键**只能包含 ASCII 字母，ASCII 数字，下划线和短横线（`A-Za-z0-9_-`）。”、XML是本身标记语法极为繁琐；不过Rime为了国际化，没有使用中文作为任何配置的键名，没有利用这一点，有些遗憾；

配置文件可以被映射为一个记录了键值对的表；给出一些信息(键)向配置文件查询，得到一个查询结果(值)；这个键值对与表查询与用输入码查码表在抽象概念上是类似的；

配置可以表达层级关系，这点与码表不同，码表没有层级（全都是一层），但配置信息较多较杂使我们需要层级这个概念帮助我们将配置分离解耦成一小块一小块的，方便理解和处理；

### 基本简单语法

- 使用缩进表示层级关系，缩进只使用空格符(一般2个空格)；
- 当然可以有顶层的键（顶格写，零缩进）；也可以缩进多层；
- 键可以没有值或下层键值；
- 缩进块必须从属于一个顶层键，否则语法错误，或者可能被错解析为属于更前面的键的层级；

- 键以冒号结尾，后面跟值或者换行的下层键值；
- 井号 `#` 开头内容表示注释，可以用在一行末尾；
- 列表项的多行写法为 从键的次行开始多一级缩进并每行一项，开头有短横杠；
- 列表项的单行写法为 值的位置方括号包裹逗号分隔；

规则看着很多，其实大概看起来就类似这样：

```yaml
# 指定引擎要对此方案使用的各类型的组件
engine:
  processors:
    - ⋯⋯
  segmentors:
    - ⋯⋯
  translators:
    - table_translator # 这个组件使用translator命名空间
    - ⋯⋯
  filters:
    - ⋯⋯

# 这是主翻译器的命名空间
translator:
  # 下面的这些配置都只作用于translator内
  dictionary: flypy_light # 指定使用的词典名，默认固态词典
  enable_completion: true
  enable_sentence: true
  enable_encoder: true
  enable_user_dict: false
```

复杂语法可以看官网文档或者直接遇到了复制粘贴问deepseek，这里不详述；

### 注意事项

YAML有较多条条框框的规则，对于初次上手修改的人来说很容易出错，列举一些注意事项：

- 语法标记都是英文符号（冒号、竖线、等等），多检查切没切输入法
- 缩进只能是空格，不能是Tab制表符！
- 会忽略纯空白符；如果你想填的值里有空格，你可以把整段值用双引号包起来避免空格被转义；

为了避免出错，推荐使用一个好的文本编辑器；个人推荐Notepad3，轻量简单易用；有语法高亮且能标记Yaml的缩进错误，能显示空白符具体是空格符还是制表符，能快速切换注释行；也可以尝试VSCode安装相关插件；

## Rime配置的拓展

Rime在YAML的基础上有额外的一些概念；包括命名空间和预编译指令等

### namespace 命名空间

约定每个顶层键是一个命名空间，或者说一个作用域；

约定每个Rime组件都可以有一个自己名称的命名空间，用户对该组件配置和选项都放在该命名空间中；

也就是说，我们一般可以一个组件一个命名空间，然后我们把属于该组件的配置项都放在该命名空间中，这样就能一目了然，方便修改；

组件实际上可以访问配置的全局信息，有些特殊组件使用的命名空间名称不是自身名称、有些则与多个组件共用一个命名空间的配置项

### 无关配置忽略

YAML解析语法需要加载整个文件，但Rime使用配置时并不关心你多余的配置，你可以在配置里任何地方写任何无关的配置内容，不会影响读取引擎所需的配置；这是因为配置文件背后是“查码表”，只要你不影响到查询的键值，你可以随便塞多少其他内容；Rime也**不会对配置文件遍历所有配置项检查是否有冗余无关的配置项**；

这样好处是你可以自由编辑配置文件，将一些自己编写的配置放在任何想要的地方，更加灵活多变；

坏处是Rime没有一份完整的“所有可配置项”的列表（一些软件程序可能会提供一个配置项模板文件，里面包含了所有可能的配置项目和详细解释，不会有更多选项，也不能缺少必要项），也很难存在这种配置列表（因为Rime的代码没有一个统一的配置项键名列表，键名分散在代码各处难以统计，并且lua插件组件也可以任意读取任何位置的配置拓展自身功能）；

注意：如果你想要配置某个设置项，但是配置了错误的键名，这种时候Rime不会有报错，也不会有提醒，因为你的配置被当作冗余配置忽略了（引擎不检查冗余配置），这种时候只能仔细检查；同时，配置也不能想当然，要确定有组件会读这个配置，才做这项配置，而不是带着“我觉得我写在这里就能生效”的想法做该项配置；

### 预编译指令

YAML本身只规定了语法，不足以满足Rime对方案配置文件的灵活处理的需求，于是Rime设计了预编译指令，拓展方案的组合能力；

更多的编译指令可以看[官方文档](https://github.com/rime/home/wiki/Configuration)，这样只举例一些常用的；

- ##### `.custom.yaml` 文件 与 `__patch` 指令

在custom文件中首先写`patch:` ，然后在作用域内写配置项；配置项的键为该配置项要的目标路径，以正斜杠 `/` 分隔每个层级；这样部署后就会覆盖原方案对应的配置节点，如：

```yaml
# 在 default.custom.yaml 文件中
patch:
  menu/page_size: 9 # 自定义每页候选个数，注释后Rime默认为5个
  menu/alternative_select_labels: [ ㊀, ㊁, ㊂, ㊃, ㊄, ㊅, ㊆, ㊇, ㊈ ]  # 自定义候选序号显示符，可任意修改
  # 上面是列表项的单行写法
  speller/auto_select: true # 自动上屏控制相关
  # ⋯⋯更多补丁⋯⋯
```

custom文件本质上是一种自动应用的预编译指令 `__patch` ，每个schema文件都会默认插入该命令：

```yaml
# schema文件中
__patch: 方案同名称.custom:/patch? # custom文件顶层的patch就是在这里指定的；
```

其中冒号前是文件名称，冒号后是要引入的组件配置；注意文件名称部分不带.yaml的扩展名；__patch来源可以手动指定，手动指定会覆盖默认设置，此时不会再尝试从custom.yaml中加载，而是你手动指定的配置节点；

配置可以来自当前文件，直接写patch的配置节点名，如：

```yaml
__patch: patch?
```

- 其中，问号表示这个修补是可选的；去掉问号时 若指向的配置节点不存在 则会报错；
- 所有指令都可以配合问号使用，不光是 `__patch` 能用；

也可以给`__patch`指令一个列表，用来指定一系列都要应用的修补内容；如：

```yaml
__patch: 
  - patch1?
  - 某配置文件.yaml:/自定义?
  - xxx.custom:/patch?
```

- ##### 列表修补语法

通过patch指令修补列表时，有一些额外的语法；

首先schema里有一个列表

```yaml
engine:
  processors:
    - ascii_composer
```

然后我们可以写一个patch、然后可以在patch里声明对列表的增加、插入、覆盖的操作；

```yaml
patch:
  # 在processors列表的末尾增加**一列表的多个**配置项
  engine/processors/+:
    - speller
    - express_editor
    
  # 在processors列表的第0个前插入**一项**（计数从0开始）
  # 键名有空格，加个双引号包起来防止被解析器误解
  "engine/processors/@before 0": lua_processor@*space_remapper
  
  # 在第0个之后插入一项
  "engine/processors/@after 0": lua_processor@*key_event_inspector
  
  # 在最后插入一项，等同于 `@after last`
  "engine/processors/@next": lua_processor@*space_remapper
  
  # 覆盖第0项的内容
  engine/processors/@0: xxx_processor
  
```

最后通过任意修补方式 如`__patch` 指令 或 custom文件自动patch，能让这个patch生效即可；

- ##### `__include` 指令

可以把另一个配置文件中的配置包含到当前位置，比如：

```yaml
# 这是schema文件，我使用了chord_composer组件，并对其进行配置；
# 因为内容比较多，而且还有很多种可供选择的变体，会占用大量篇幅，
# 所以将其拆分到了单独一个文件，方便维护管理
# 这个文件我直接使用命名空间的名称；
chord_composer:
  # 引入chord_composer.yaml文件中的“自定义1”下的所有配置项
  __include: chord_composer.yaml:/自定义1
```

```yaml
# 这是chord_composer.yaml
自定义1:
  alphabet: qazwsxedcrfvtgb12345yhnujmik,ol.p;/67890'-`[= \]
  algebra:
    - xform=(<qv>|<mp>)=Q=
    - xform=(<wv>|<mo>)=W=
    - xform=(<ev>|<mi>)=E=
    - xform=(<et>|<yi>)=R=
    - xform=(<qt>|<yp>)=T=
    - xform=(<wg>|<ho>)=Y=
    - xform=(<wt>|<yo>)=U=
    - xform=(<eg>|<hi>)=I=
    - xform=(<aw>|<oA>)=O=
    - xform=(<qf>|<jp>)=P=
    # ⋯⋯⋯⋯剩余300多行⋯⋯⋯⋯
  output_format:
    - xform=<"(.+)>(.*)$=|$1$2|=
    - xlit/无一二三四五中/012345C/
    - xlit|；，。、|;,./|
  prompt_format:
    - xform=<"(.*)>=:$1=
    - xform=^ $=_=
    - xlit|一二|壹贰|
    - xform=^:0f$=_=
# 可以放多种备选项
# 没有用到的备选命名空间的配置项不会被编入构建产物中
自定义2:
    alphabet: qazwsxedcrfvtgb12345yhnujmik,ol.p;/67890
    # 下略……
自定义3:
    alphabet: ⋯⋯⋯⋯
    # 下略……
```

默认的default.yaml文件中也用了此方式来引用key_bindings.yaml和punctuation.yaml中的配置

> 预编译指令的语法不重要，语法都是人定的，按需要学习使用、能达成目的即可；同时不建议在方案上手动使用过多预编译指令，避免将方案弄得复杂化不易理解；



### 简要解释一下正则表达式与拼写运算

