# Rime组件模型与执行流程

Rime是一个可以高度自定义的输入法引擎，这背后离不开它的 **组件化** 支持 —— 将功能抽离解耦成一个个小模块、组件(Component)，以便它们可以像拼积木一般被组合使用；

在已有了大量组件的情况下，Rime如何组织起这些组件来运行呢（先不管组件是哪儿来的）；



## 1、Rime的组件执行流程

下面给出几条规则：

1. 我们定义一个"触发合成"(Compose))的流程如下：

​	` (触发Compose流程) -> Segmentors -> Translators -> Filters -> (结束Compose流程，返回调用处)`

​	这个流程可以被调用；

2. 然后我们有

​	`(Rime引擎接受外部系统平台击键事件输入) -> Processors -> (Rime引擎向外回复击键事件处理结果)`

​	其中：

​		每个processor在执行过程中，有许多操作会导致"触发合成"

​		若“触发合成”了，规则1的“Compose流程”会在该processor的 处理操作过程中 被调用执行：

3. 对于每一个组件类别下的**若干具体组件**，则是很直接地，按方案配置中 各组件**列出的顺序** **逐项**执行。

> 由上述规则可看出，“Compose流程”没有一个同Processors一般的，显式的 固定的 开始执行的入口，而是依赖于Processor的触发；Rime的组件执行流程实际上是以Processors的处理流程为主线的；



#todo 欠图一张，此处直接画出图来表现更合适



> 若一下没看明白，不着急，我们先把每个组件的介绍过一遍，然后把需求与限制梳理一番，最后再回过头来看这个流程，就能轻易弄懂了；

下面我们先来简单讨论下每个组件类型的用意；



## 2、四大类组件

Rime的四种组件类型分别是：

- Processor （击键事件处理器）
- Segmentor （输入码分段器）
- Translator （输入码翻译器）
- Filter （候选项“滤镜”）

### Processor

- 接收击键事件参数，操作Rime引擎接口，返回击键事件处理结果

当你使用键盘在电脑上打字的时候，你按下的是键盘上的按键，这些按键的按下状态变化会通过通信协议和驱动程序等发送给操作系统；而操作系统接受到后，会 根据按键信息和系统配置 生成“击键事件”；（下面是对击键事件的一个大体的感受，用作整体模糊的了解，大致是以Windows系统为描述主体；可能存在许多不准确之处）

#### 击键事件(Key Event)

我们期望击键事件应该被有次序地发送给当前窗口程序和想要接受这个击键事件的程序和软件等，保证程序接受到的顺序与你实际输入的顺序一致；

并且，“事件”应当只被处理一次，你的一波输入操作默认只应该让一个应用程序来处理；

> 这也符合我们的日常使用习惯和操作逻辑，比如按Alt+F4可以关闭程序，你按一下肯定意图是关闭一个，而不是一下子全部程序都关闭了；

但是，程序向操作系统“订阅”击键事件，只能在“要订阅”和“不要订阅”之间选，没有“我只订阅某类键/某几个键”的选项；“订阅” 在这里我指的是：*如果有新的(击键事件)产生了，(程序)就会被“通知”* *（而具体的击键事件内容读取与判断处理，由应用自己来做）*；这样也使得操作系统可以保持自身处理流程逻辑简明；

——因此，应用程序必然会接受到很多并非自己所关注的击键事件；而程序需要自己读取判断击键事件，并做出处理

另一方面，由于操作系统同时运行着很多程序/窗口界面，实际上操作系统还需要考虑 击键事件先给谁后给谁 的问题；于是操作系统有个程序优先级排序，按照这个优先级的队列一个个地传递，通知程序产生了击键事件； 而被通知的应用也需要考虑到因为其他程序软件的存在，需要告诉操作系统 自己是否处置掉了这个击键事件，操作系统是否应该继续 对优先级队列中排在后面的程序 通知和传递击键事件；

——因此，应用程序在处理完击键事件后，需要告诉操作系统自己的处置结果（一般是以事件处理的回调函数的返回一个布尔值的形式）

> 如此一套不很复杂的架构，足以完成多样的需求。举个例子：
> 我同时开着键盘热键重映射软件、输入法，使用一个具有键盘快捷键交互功能的软件；
> （热键重映射的软件一般会通过系统接口将自己设置到优先级最高，保证自己可以先于一切其他程序接收到系统的击键事件，以确保完成热键重映射；而输入法一般是由操作系统保证在当前焦点窗口程序之前先取得击键事件；而前台/聚焦的窗口程序比后台的窗口更优先）
> 当我按下一组我想要交给窗口程序的快捷键时：首先会被热键重映射软件接收到，它判断此组合键不在它需要处理的范围内，于是返回给操作系统一个“未处理，请继续传递”的信息；于是操作系统继续传递向下一个程序，到了输入法，输入法一看，这个键是组合修饰键，显然不是输入用的，于是也回复操作系统“未处理”；于是操作系统继续传递，终于到了前台窗口程序，前台窗口程序判断发现自己有相关快捷键的功能，于是开始执行相关功能，完成后向操作系统发出“已处理，不必再传递”的信息；于是操作系统认为这个击键事件已经被妥善处理，就停止了对该事件的传递，并准备处理下次的击键事件；

#### 类比到Processor

Rime的Processors处理流程与前述的架构基本一致；Rime引擎接受来自操作系统的击键事件后，按顺序轮询每一个processor；
每个processor主要只根据自己要实现的功能，来判断当前的击键事件如何处理：

- 当processor发现此击键事件是自己功能相关，需要自己处理时，该processor在处理完成后，向Rime返回`kAccepted`(接受)，表示此击键事件已被处理，于是Rime结束Processors流程，并向操作系统返回“已处理”；操作系统也完成和结束这次击键事件处理，不再向后续其他程序继续传递了；
- 当processor发现此击键事件是自己功能无关的，不需要干涉时，就向Rime返回`kNoop`(什么都不做)；此时Rime将该击键事件流转给下一个processor处理；直到流转给最后一个processor仍然返回`kNoop`时，也就意味着所有的processor都选择不处理该击键事件；则向操作系统返回“未处理”；操作系统继续将该击键事件通知其他优先级顺位程序处理；
- 当processor发现此击键事件为需要 为后续的processor排除 的击键事件时，可以选择向Rime引擎返回`kRejected`（弹出,拒绝）；此时Rime将中断该击键事件继续向后续的processor传递，并直接向操作系统返回“未处理”，以达到 中止Processors处理流程 的目的；此时操作系统也会继续将该击键事件通知给优先级队列处在后面的程序处理；

概括一下：

- 遇到有processor“要接受”(`kAccepted`) => Rime引擎“已处理”
- 所有processor都“不理睬”(`kNoop`) => Rime引擎“不处理”
- 遇到有processor“要拒绝”(`kRejected`) => Rime引擎“不处理”

另外一点值得注意的事情：

> “已处理” “未处理”、 “接受” “拒绝” “不理睬”，这些返回了的处理结果，与在处理过程中实际做没做处理、做了什么处理 并没有任何关联：你完全可以对击键事件做了处理后，又返回“不理睬”(`kNoop`) 或 “拒绝”(`kRejected`)，并不冲突；返回值本质是只用来回复是否还要继续流转击键事件；这种操作对特定场景有用，按实际需要使用；



### Translator

- 接收输入码，操作候选栏，无返回值

​	为什么不是按顺序讲Segmentor，而是跳过了它先讲Translator呢，因为Segmentor比较复杂，可以放到后面一点再来说；

显然输入法除了要处理按键事件，还要做的一件非常重要的事情就是查表：汉字输入法的编码排布信息计算机不可能凭空得出，需要依赖方案作者预先准备好 组织良好的 键值对数据，即表格、码表；而查这个表就是Translator的职责了，十分地浅显易懂。
