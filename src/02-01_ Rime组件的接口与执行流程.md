# Rime组件的接口与执行流程

Rime是一个可以高度自定义的输入法引擎，这背后离不开它的 **组件化** 支持 —— 将功能抽离解耦成一个个小模块、组件(Component)，以便它们可以像拼积木一般被组合使用；

在已有了大量组件的情况下，Rime如何组织起这些组件来运行呢（先不管组件是哪儿来的）；



## 1、Rime的组件执行流程

下面给出几条规则：

1. 我们定义一个"触发合成"(Compose))的流程如下：

​	` (调用处触发Compose流程) -> Segmentors -> Translators -> Filters -> (结束Compose流程，返回调用处)`

​	这个流程可以被调用；

2. 然后我们有主流程如下：

​	`(Rime引擎接受系统平台的外部击键事件输入) -> Processors处理 -> (Rime引擎向外回复击键事件处理结果)`

​	其中：

​		每个processor在执行过程中，有许多操作会导致"触发合成"

​		若“触发合成”，规则1的“Compose流程”会在该processor的 处理操作过程中 被调用执行：

3. 对于每一个组件类别下的**若干具体组件**，则是很直接地，按方案配置中 各组件**列出的顺序** **逐项**执行。

> 由上述规则可看出，“Compose流程”没有一个同Processors一般的，显式的 固定的 开始执行的入口，而是依赖于Processor的触发；Rime的组件执行流程实际上是以Processors的处理流程为主线的；



#todo 欠图一张，此处直接画出图来表现更合适



> 若一下没看明白，不着急，我们先把每个组件的介绍过一遍，然后把需求与限制梳理一番，最后再回过头来看这个流程，就能轻易弄懂了；

下面我们先来简单讨论下每个组件类型的用意；



## 2、四大类组件

Rime的四种组件类型分别是：

- Processor （击键事件处理）
- Segmentor （输入码分段）
- Translator （输入码片段翻译）
- Filter （候选项处理与过滤）

### Processor

- 接收击键事件参数，操作Rime引擎接口，返回击键事件处理结果

当你使用键盘在电脑上打字的时候，你按下的是键盘上的按键，这些按键的按下状态变化会通过通信协议和驱动程序 等 发送给操作系统；而操作系统接受到后，会 根据按键信息和系统配置 生成“击键事件”；

> 下面是对击键事件的一个大体的感受，用作整体模糊的了解，大致是以Windows系统为描述主体；可能存在许多不准确之处

#### 击键事件(Key Event)

我们期望击键事件应该被有次序地发送给当前窗口程序和想要接受这个击键事件的程序和软件等，保证程序接受到的顺序与你实际输入的顺序一致；

并且，“事件”应当只被处理一次，你的一波输入操作默认只应该让一个应用程序来处理；

> 这也符合我们的日常使用习惯和操作逻辑，比如按Alt+F4可以关闭程序，你按一下肯定意图是关闭一个，而不是一下子全部程序都关闭了；

一个程序会接受到很多并非自己所关注的击键事件；而程序需要自己读取判断击键事件，并做出处理：因为操作系统同时运行着多个程序/窗口界面，并不知道某个程序关注什么击键事件，只能将所有的击键事件都每个程序问一遍；

操作系统其实还需要考虑 击键事件传递次序问题，先给谁后给谁；于是操作系统大概有个程序优先级排序，按照这个优先级的队列一个个地传递，通知程序产生了击键事件； 而被通知的应用也需要考虑到因为其他程序软件的存在，需要告诉操作系统 自己是否处置掉了这个击键事件，操作系统是否应该继续 对优先级队列中排在后面的程序 通知和传递击键事件；

因此，应用程序在处理完击键事件后，需要告诉操作系统自己的处置结果（通常用一个布尔值就足以表示返回结果了）

> 如此一套不很复杂的架构，足以完成多样的需求。举个例子：
> 我同时开着键盘热键重映射软件、输入法，并同时使用一个具有键盘快捷键交互功能的普通应用软件；
> （热键重映射的软件一般会通过系统接口将自己设置到优先级最高，保证自己可以先于一切其他程序接收到系统的击键事件，以确保完成热键重映射；而输入法一般是由操作系统保证在当前焦点窗口程序之前先取得击键事件；而前台/聚焦的窗口程序比后台的窗口更优先）
> 当我按下一组我想要交给窗口程序的快捷键时（比如Ctrl+C）：首先会被热键重映射软件接收到，它判断此组合键不在它需要处理的范围内，于是返回给操作系统一个“未处理，请继续传递”的信息；于是操作系统继续传递向下一个程序，到了输入法，输入法一看，这个键是组合修饰键，显然不是输入用的，于是也回复操作系统“未处理”；于是操作系统继续传递，终于到了前台窗口程序，前台窗口程序判断发现自己有相关快捷键的功能，于是开始执行相关功能，完成后向操作系统发出“已处理，不必再传递”的信息；于是操作系统认为这个击键事件已经被妥善处理，就停止了对该事件的传递，并准备处理下次的击键事件；

#### 类比到Processor

Rime的processors处理流程与前述的架构基本一致：

> Rime就是整个输入法内的“操作系统”，每一个processor就是“操作系统”中的一个个接收击键事件的应用程序；Rime引擎接受来自操作系统的击键事件后，按顺序轮询每一个processor。

每个processor主要只根据自己要实现的功能，来判断当前的击键事件如何处理：

- 当processor发现此击键事件是自己功能相关，需要自己处理时，该processor在处理完成后，向Rime返回`kAccepted`(接受)，表示此击键事件已被处理，于是Rime结束Processors流程，并向操作系统返回“已处理”；操作系统也完成和结束这次击键事件处理，不再向后续其他程序继续传递了；
- 当processor发现此击键事件是自己功能无关的，不需要干涉时，就向Rime返回`kNoop`(什么都不做)；此时Rime将该击键事件流转给下一个processor处理；直到流转给最后一个processor仍然返回`kNoop`时，也就意味着所有的processor都选择不处理该击键事件；则向操作系统返回“未处理”；操作系统继续将该击键事件通知其他优先级顺位程序处理；
- 当processor发现此击键事件为需要 为后续的processor排除 的击键事件时，可以选择向Rime引擎返回`kRejected`（弹出,拒绝）；此时Rime将中断该击键事件继续向后续的processor传递，并直接向操作系统返回“未处理”，以达到 中止Processors处理流程 的目的；此时操作系统也会继续将该击键事件通知给优先级队列处在后面的程序处理；

概括一下：

- 遇到processor“要拒绝”(`kRejected`) => Rime引擎“不处理”

- 遇到processor“要接受”(`kAccepted`) => Rime引擎“已处理”
- 所有processor都“不理睬”(`kNoop`) => Rime引擎“不处理”

注意：

> “已处理” “未处理”、 “接受” “拒绝” “不理睬”，这些返回了的处理结果，与在处理过程中实际做没做处理、做了什么处理 并没有任何关联：你完全可以对击键事件做了处理后，又返回“不理睬”(`kNoop`) 或 “拒绝”(`kRejected`)，并不冲突；返回值本质是只用来回复是否还要继续流转击键事件；这种操作对特定场景有用，按实际需要使用；



### Translator

- 接收输入码片段，产生候选项，无返回值

显然输入法除了要处理按键事件，还要做的一件非常重要的事情就是查表：汉字的编码排布信息输入法不可能凭空得出，需要依赖方案作者预先准备好 组织良好的 键值对数据，即表格、码表；而查这个表就是translator的用途了（十分易懂）。

Rime可以声明多个translator；多个translator之间应当彼此完全无干扰，并且使用的效果也应当不受在组件列表中的声明顺序影响；

可以为每一个translator指定优先级，高优先级translator产生的候选项会排在低优先级translator的前面；但是多个translator之间的候选项不会交叉混排，一个translator产生的全部候选项会作为一个整体来排；（是这样吗，需要实践确认，存有一小点疑）

translator不需要返回值，return一个“空”来中断其处理流程。

注意：

> 一旦将候选项“交付”给Rime引擎了，就不能再向Rime引擎要求退回了；一般在translator内部先开一个队列暂存，等到内部查完排好序了，再一齐向Rime引擎交付。



### Filter

- 接收所有候选项，产生候选项，无返回值

filter与translator的接口能力类似，都是产生候选项，没有返回值；但是两者区别在于，filter看到的是整一个候选项队列，是完整的有一定顺序的，是多个translator产生的结果；而translator则是只能看到、生成和处理自己一个translator内部的候选项，看不到其他translator的结果；

注意：

> filter向Rime引擎交付候选项的接口与translator遵循相同的限制，向Rime引擎“交付”后，候选项无法要求退回；因此如果有多候选项比较处理判断等功能的需求，可以一样开一处空间暂存所有候选项，等到处理完了再一齐向Rime引擎“交付”。



