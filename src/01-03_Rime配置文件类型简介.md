# Rime配置文件类型简介

> 了解 *Rime配置*  的相关概念有助于我们吃好Rime .

### Rime配置概览

Rime的程序与数据是分离的。在你下载安装完Rime输入法软件后，发行版并非一定有自带一套默认配置，所以你可以（并且也大概需要）自己准备Rime配置。#todo 分离程序与数据有诸多好处，方便重置等

Rime的配置放在通常称为“用户文件夹”的路径下，且一般此文件夹名称为`Rime`，Rime配置的形式为若干松散文件及文件夹，内容上可以分为`具体输入方案相关配置`、`Lua插件`、`Rime引擎配置相关` 和 `Rime前端配置相关`。其中具体输入方案相关配置通常可以分为 输入方案配置文件(`*.schema.yaml`) 和 词典文件(`*.dict.yaml`)。

下面是一份示意图，尽可能分类列出了Rime用户配置文件夹中可能出现的文件及其用途：

<img src="./01-03_Rime配置文件简介_Rime配置文件的可能构成.svg" style="width: 60%; display: block; margin: 0 auto;"/>

#todo 换个思维导图制图的排版形式

下面先从文件类型的角度出发分述详解



## 0、一些零散概念

### deploy 部署阶段

Rime在启动时有一个预先进行准备的部署阶段，在此期间会由deployer部署器执行若干操作，包括：处理方案yaml文件与定制yaml文件、处理Rime的预编译指令、编译词典文件等；可以手动触发部署器执行部署操作；

部署阶段产生的文件在build目录下；Rime加载大部分配置文件所使用的不是你原本的用户文件夹里的方案文件，而是经部署处理的在build目录下的文件；

构建出的文件存有依赖项对应的修改时间戳，通过修改时间判断是否需要重新部署编译该构建文件；

### 用户文件夹 与 程序文件夹

用户文件夹就是你现在放方案的位置，所有你的用户数据都在该路径下；数据归在当前操作系统登录用户下，切换当前登录的用户则会加载新的当前登录用户的文件夹，由操作系统保证用户数据的隔离

程序文件夹是Rime输入法被全局安装的位置，其中可能有带一套全局默认数据放在某目录下；用户文件夹在初始化时会将全局默认数据完全复制一份；

### 日志查看

不同的发行版的日志查看方式不同；官方的Rime发行版可以在部分文档中看到日志文件路径，如官版小狼毫在%TEMP%目录下；输入法图标右键菜单可能会有快捷打开日志文件的选项；

较为特殊的是fcitx5平台，由于其跨平台特性，fcitx5-rime不写出日志文件，如需查看日志，可在命令行使用`待补充`查看日志输出；



## 1、具体输入方案相关

### schema 方案配置文件

每一个被正确编写配置的.schema.yaml文件会被Rime识别为一个方案，被识别的方案会出现在“输入法设定”方案启用勾选列表中，并显示作者和方案介绍等信息；schema也是Rime方案切换、方案部署的单元，也是引擎加载方案配置的入口；如果方案有语法错误，则会解析失败且不会出现在启用勾选列表中；

一个schema中应当有一个**主要**的Translator，Rime的部署器将只选择此主Translator使用的词典文件进行编译处理；非主要Translator(或称副翻译器) 可以加载已编译好的词典，但不能令部署器根据其使用词典名编译对应词典；如果指定一个未编译的词典名，Rime会在日志里报错，信息类似“未找到某某词典”；

一个schema可以依赖另一个schema，部署器会先部署所依赖的schema，此依赖schema不需要被设为启用方案；如果形成了循环依赖，引擎会在日志里报错；

### custom 定制文件  、yaml 配置文件

部署器会在部署阶段将custom文件与同名的schema文件进行合成，用custom的配置覆盖schema的配置，并将合成后的schema配置放在build下；

也可以在schema中使用Rime部署器的预编译指令，可以指定加载任意名称的yaml文件中的任意部分命名空间配置 将其引入到当前声明的位置，部署器会合成这些配置数据并将生成的新的schema文件放在build下； custom文件实际上是对方案文件自动生效的预编译修补指令使用的文件；

两种方式都是对既有方案的定制和修改，有各自的用途：前者通常用于使用外部获取下载的方案，配置文件可能在未来覆盖更新，所以需要将修改放在独立的文件中，使修改内容不因为覆盖更新而丢失；后者则可以用来对复杂方案的解耦，可以将过于复杂的局部配置拆分到独立的文件中方便浏览修改，也可以实现 方案设计给出多种预设好的配置选择 的功能；

### dict 固态词典 与 编译产物

词典文件后缀名为.dict.yaml，是一个码表、键值对，它像Excel表格一样存储编码和候选词的信息；主体内容是以tab分隔的候选词与编码和可选的权重值；编码中的分段使用空格切分

固态词典可以指定在编译前从另一个词典文件中加载条目；Rime默认会为所有固态词典引入内置的“八股文”词典(essay.txt文件)，可以在配置中声明禁用；

由于直接对原始文本的码表进行高频大量查表性能不佳等原因，Rime使用了库来编译词典为可被高效查询的二进制文件；因为需要编译且产物为了优化不可增量编译，就像被压实了一样，也有固态词典的名称；词典编译操作在部署阶段执行；固态词典使用的类似Radix-Trie的数据结构，使用库marisa；

词典编译出的二进制文件有三种类型：

- 主表.table.bin，从编码到候选词的正查表；
- 反查表.reverse.bin，从候选词编码的反向查找表，可用于反查某字编码；
- 编码项映射表.prism.bin，“棱镜”，对每个编码按照“拼写运算”的规则得出的逆关系的映射表；通常用于在进行正查前先对输入编码预先查找一次尝试将其映射为主表中存在的编码，若存在映射结果，再以之查主表；可节省实现多编码同一候选词功能所占存储空间；常用于实现静态模糊音功能与静态简拼功能；

词典编译操作对于较大的码表耗时较久，且部署器每次检测到码表文件有修改都将触发重新编译；由于是优化后的二进制文件，编译出的二进制文件不支持增量编译或局部修改，因此频繁编译会导致反复地覆盖文件，产物文件过大会使消耗的硬盘寿命较多，且编译过程耗时较长并会占用大量内存；

因此：非常建议对码表拆分，将码表经常修改的部分单独列出一个词典文件存放，尽可能减少对大型码表的修改次数，尽可能不要触发码表大头部分的重新编译；对于码表大头的修改可以改为动态修复、用新词典实现候选项覆盖提前，用lua插件动态屏蔽码表中不想要的词，不修改原码表文件避免触发编译；对于高频查找的核心基础单字和词汇，也可以单放一个词典编译，较小的产物文件可能有助于提升查表性能；对于海量低频语料型短语词句，应处理成语法模型而不宜用作固态码表；

注：不当的“棱镜”拼写运算设计可能导致部分编码海量匹配结果与运算（尤其是静态简拼功能）**显著卡顿**，注意谨慎使用；

可以使用词典包相关配置指定一组词典编译，但此时不会编译任何反查表和和“棱镜”表，只会编译出每个词典的主表；

### stabledb 码表词典

这种把条目直接写在一个txt文件中的词典不需要编译，Rime中把这种码表类型命名为stabledb（代码实现上，StableDb继承了TableDb，TableDb继承了TextDb；StableDb是只读模式打开的TableDb，两者都取.txt为扩展名）；通常用于存放条目不多的自定义短语，常见custom_phrase.txt、essay.txt；支持#号打头做注释，主体内容的格式与dict相同为tab分隔的候选词与编码等；可以在schema中用非主Translator加载使用；

由于不需要编译，不用担心经常修改导致的部署阶段反复编译的开销；但是条目数量非常多时可能查询性能不佳；

### userdb 用户词典

用户词典是动态生成的一个名称带有后缀.userdb的文件夹和文件夹内的松散文件；用户词典支持动态写入和更新且操作开销较小；存储的二进制文件可以导出为文本码表；实现上使用的是LSM数据结构，使用库leveldb；Rime引擎运行时会独占其中文件，不能被外部程序读取；

通常只用来记录和更新上屏候选项的词频和用户造词，绑定在Translator使用，只会在使用时生成，通常方案不会将用户词典作为方案的一部分发布；

### octagram 语法模型

gram语法模型文件，本质上是一个Darts数据结构(双数组前缀树，不是flutter的编程语言darts)的表，存储内容为：n字短语词句的前n-1字、第n字(最末字)、第n字在前n-1字条件下的字频(的对数值)（n字短语词句会自动将分离最末字的两部分作为键，源词频表文件实际上不需要手动分解标记）；可以高效存储大量前缀相同的项如“我今天吃了饭”、“我今天吃了面”，并对每种情况的末字标注词频；

若要使用语法模型，需要rime引擎支持librime-octagram插件（大部分情况下Rime的发行版都具有此插件，但一些特殊情况下插件可能不存在而无法使用）

无法在Rime输入法中实现语法模型的创建修改和编译；目前只能在开发环境中从文本码表转换出语法模型文件；

语法模型只能挂在主翻译器下使用，不支持副翻译器；

> 我对librime-octagram的了解也不保证全面和完全正确，下述内容可能存在错漏：

语法模型启用后，在Translator未查到输入码完整匹配候选项，且开启了造词造句功能时激活：从 ~音码每个音节 / 形码每个最长查询命中部分 所能查到的候选项里~，挑选指定数量的前n个候选词，进行全组合，计算所有组合词应有的词频，计算方法为以每个用于组合的候选词的概率 乘上   该候选词位于 前面指定数量的字 之后   的概率；从这些组合中排序出最终词频最高的组合出的候选项，作为构词结果；

> 不准确，实际上形码编码并非只取最长查询有候选项部分，而是可以取到最短一码，例如我用小鹤音形方案测试，输入码dgoge，给出的候选项是`d'goge：的国歌` 而不是`dgog'e：戥二`，其中dgog才是最长命中编码；
>
> 因此应该修改为：对从每个最长查询命中的编码片段，到最短一位编码的所有输入码分段情况进行组合遍历：对每一种分段组合，取其中每个分段的最高概率的数个候选项（可指定数量），组合出一个候选项并计算其概率；然后根据 所有分段组合的所有候选项组合出的候选项 取出最高概率的那一个候选项作为结果？

语法模型可以极大程度的改进构词准确性，但不当的设置可能会拖慢Rime性能；

### predict 联想词数据库

联想词的数据库文件；让Rime具备如同手机输入法的联想词的功能，选中上屏后不结束输入而是继续直接提供联想候选项可以继续直接上屏；

需要Rime引擎支持librime-predict插件；按照项目页的说明添加predictor处理器等操作即可；

db数据库文件可以使用通用数据库浏览软件创建与读写；



## 2、Lua插件相关

lua插件是由librime-lua提供的使用lua脚本实现对Rime组件编程功能的lua脚本，librime-lua是一个librime插件（注意区分librime插件和lua插件的异同）

使用lua插件需要librime支持librime-lua，如果不支持，则解析方案所用组件列表时 不能识别lua插件引用语法，会直接在日志中报错；

### rime.lua

rime.lua文件是老版本Rime（的老版本librime-lua插件）加载插件的唯一方式，通过将所有的插件代码写在同一个文件里来方便加载和调用；但由此导致了插件分发修改困难：外部获取插件的代码文件不能直接使用，而要手动编辑加入rime.lua文件；且对方案自带文件修改会导致更新方案时文件覆盖丢失修改；因为这些耦合问题，已不再推荐使用；

此文件是特需文件，不存在时Rime会自动从全局默认数据中加载对应文件；可能会因此导致一些冲突，在冲突的情况下，可以在用户文件夹中创建一个占位的空白文件，避免Rime加载冲突的默认lua代码；

### lua/*.lua

为了解决rime.lua文件的耦合问题都来的不便，新版本的rime（的librime-lua插件）可以将一个插件单独放在一个lua文件里，并统一放在lua文件夹下与方案文件分离方便文件管理；

### 动态链接库（`*.dll`、`*.dylib`、 `*.so` ）

lua脚本不能直接操作系统接口，实现如网络访问、显示窗口等操作；因此可以将调用系统接口的动态链接库提供给lua调用，从而使lua具备部分系统调用能力；一般只有特别需要的插件才会使用这些库，通常需要用户按照插件说明自行放置；

动态库文件不跨平台，需要为每个平台准备专门的库文件；



## 3、特需文件

有一些文件是对于Rime引擎是必须要存在的；这些文件具有固定的名称，算是Rime对用户文件夹中的数据的“抓手”和“入口”，也记录了一些用户使用信息；

部分特需文件不存在于用户文件夹时，Rime会自动尝试读取加载全局默认数据中的对应的文件（但不复制该文件至用户文件夹）；如果加载不到，Rime可能会尝试初始化用户文件夹或在日志中报错；

### default.yaml

默认配置文件，会被加载，当尝试从方案中读取某项配置没有查找到时，会再尝试从默认配置中读取；

一些常用功能的设置项也通常被放在这个文件中，包括

- 启用方案列表
- 方案选单呼出组合键
- 每页候选项数量

可以在每个方案中再配置覆盖default.yaml中的默认配置，这样可以不同方案使用各自的设置，在切换到方案时生效；

default.yaml文件通常还会通过预编译指令引用key_bindings.yaml 和 punctuation.yaml，两者分别包含了按键映射和标点控制相关功能

一般对default.yaml的修改通过default.custom.yaml完成，而不修改原文件，当然也可以直接新建一个空白的default.yaml文件，不使用发行版自带的配置项；

### rime.lua

前面提过了，不赘述

### installation.yaml

包含了发行版的安装信息，用户不需要改动该文件

### user.yaml

对一些选项的记忆，在引擎启动时从该文件加载恢复；包括上次选择方案、方案最后访问时间（可供方案选单列表按使用记录排序）

### 前端相关配置文件（weasel.yaml等）

供给前端读取的配置文件，与引擎配置文件分离；可以修改文件设置候选项外观等功能；
