# Rime组件接口与执行流程

Rime是一个可以高度自定义的输入法引擎，这背后离不开它的 **组件化** 支持 —— 将功能抽离解耦成一个个小模块、组件(Component)，以便它们可以像拼积木一般被组合使用；

在已有了大量组件的情况下，我们先来看看Rime如何组织这些组件运行；



## 1、Rime的组件执行流程

下面给出几条规则：

1. 首先定义一个"触发合成"(Compose))的流程如下：

​	` (触发或调用Compose流程) -> Segmentors -> Translators -> Filters -> (结束Compose流程，返回调用处)`

​	这个流程可以被调用；

2. 然后有主流程如下：

​	`(Rime引擎接受系统平台的外部击键事件输入) -> Processors处理 -> (Rime引擎向外回复击键事件处理结果)`

​	其中：

​		每个processor在执行过程中，有许多操作可以导致"触发合成"

​		若“触发合成”，规则1的“Compose流程”会在该processor的 处理操作过程中 被调用执行；

​		processor也可以手动调用触发Compose流程；

3. 对于每一个组件类别下的**若干具体组件**，直接按方案配置中 各组件**列出的顺序** **逐项**执行。

> 由上述规则可看出，“Compose流程”没有一个同Processors一般的，显式的 固定的 开始执行的入口，而是依赖于Processor的触发；Rime的组件执行流程实际上是以Processors的处理流程为主线的；



#todo 欠图一张，此处直接画出图来表现更合适



下面来简单讨论下每个组件类型的用意；



## 2、四种组件类型

Rime的四种组件类型分别是：

- Processor （击键事件处理）
- Segmentor （输入码分段）
- Translator （输入码片段翻译）
- Filter （候选项处理与过滤）

### Processor（处理器）

- 接收击键事件参数，操作Rime引擎接口，返回击键事件处理结果

当你使用键盘在电脑上打字的时候，你按下的是键盘上的按键，这些按键的按下状态变化会通过通信协议和驱动程序 等 发送给操作系统；而操作系统接受到后，会 根据按键信息和系统配置 生成“击键事件”；

> 下面是对击键事件的一个大体的感受，用作整体模糊的了解，大致是以Windows系统为描述对象；可能存在许多不准确之处

#### 击键事件(Key Event)

我们期望击键事件应该被有次序地发送给当前窗口程序和想要接受这个击键事件的程序和软件等，保证程序接受到的顺序与你实际输入的顺序一致；

并且，“事件”应当只被处理一次，你的一波输入操作默认只应该让一个应用程序来处理；

> 这也符合我们的日常使用习惯和操作逻辑，比如按Alt+F4可以关闭程序，你按一下肯定意图是关闭一个，而不是一下子全部程序都关闭了；

一个程序会接受到很多并非自己所关注的击键事件；而程序需要自己读取判断击键事件，并做出处理：因为操作系统同时运行着多个程序/窗口界面，并不知道某个程序关注什么击键事件，只能将所有的击键事件都每个程序问一遍；

（此处应有一张图来更好描述）

操作系统其实还需要考虑 击键事件传递次序问题，先给谁后给谁；于是操作系统大概有个程序优先级排序，按照这个优先级的队列一个个地传递，通知程序产生了击键事件； 而被通知的应用也需要考虑到因为其他程序软件的存在，需要告诉操作系统 自己是否处置掉了这个击键事件，操作系统是否应该继续 对优先级队列中排在后面的程序 通知和传递击键事件；

因此，应用程序在处理完击键事件后，需要告诉操作系统自己的处置结果（通常用一个布尔值就足以表示返回结果了）

> 如此一套不很复杂的架构，足以完成多样的需求。举个例子：
> 我同时开着键盘热键重映射软件、输入法，并同时使用一个具有键盘快捷键交互功能的普通应用软件；
> （热键重映射的软件一般会通过系统接口将自己设置到优先级最高，保证自己可以先于一切其他程序接收到系统的击键事件，以确保完成热键重映射；而输入法一般是由操作系统保证在当前焦点窗口程序之前先取得击键事件；而前台/聚焦的窗口程序比后台的窗口更优先）
> 当我按下一组我想要交给窗口程序的快捷键时（比如Ctrl+C）：首先会被热键重映射软件接收到，它判断此组合键不在它需要处理的范围内，于是返回给操作系统一个“未处理，请继续传递”的信息；于是操作系统继续传递向下一个程序，到了输入法，输入法一看，这个键是组合修饰键，显然不是输入用的，于是也回复操作系统“未处理”；于是操作系统继续传递，终于到了前台窗口程序，前台窗口程序判断发现自己有相关快捷键的功能，于是开始执行相关功能，完成后向操作系统发出“已处理，不必再传递”的信息；于是操作系统认为这个击键事件已经被妥善处理，就停止了对该事件的传递，并准备处理下次的击键事件；

#### 类比到Processor

Rime的processors处理流程与前述的架构基本一致：

> Rime就是整个输入法内的“操作系统”，每一个processor就是“操作系统”中的一个个接收击键事件的应用程序；Rime引擎接受来自操作系统的击键事件后，按顺序轮询每一个processor；每个processor调用Rime接口处理，处理完成后返回处理结果；

每个processor主要只根据自己要实现的功能，来判断当前的击键事件如何处理：

- 当processor发现此击键事件是自己功能相关，需要自己处理时，该processor在处理完成后，向Rime返回`kAccepted`(接受)，表示此击键事件已被处理，于是Rime结束Processors流程，并向操作系统返回“已处理”；操作系统也完成和结束这次击键事件处理，不再向后续其他程序继续传递了；
- 当processor发现此击键事件是自己功能无关的，不需要干涉时，就向Rime返回`kNoop`(什么都不做)；此时Rime将该击键事件流转给下一个processor处理；直到流转给最后一个processor仍然返回`kNoop`时，也就意味着所有的processor都选择不处理该击键事件；则向操作系统返回“未处理”；操作系统继续将该击键事件通知其他优先级顺位程序处理；
- 当processor发现此击键事件为需要 为后续的processor排除 的击键事件时，可以选择向Rime引擎返回`kRejected`（弹出,拒绝）；此时Rime将中断该击键事件继续向后续的processor传递，并直接向操作系统返回“未处理”，以达到 中止Processors处理流程 的目的；此时操作系统也会继续将该击键事件通知给优先级队列处在后面的程序处理；

概括一下：

- 遇到processor“要拒绝”(`kRejected`) => Rime引擎报“不处理”

- 遇到processor“要接受”(`kAccepted`) => Rime引擎报“已处理”
- 所有processor都“不理睬”(`kNoop`) => Rime引擎报“不处理”

注意：

> “已处理” “未处理”、 “接受” “拒绝” “不理睬”，这些返回了的处理结果，与在处理过程中实际做没做处理、做了什么处理 并没有强制绑定关系：你完全可以对击键事件做了处理后，又返回“不理睬”(`kNoop`) 或 “拒绝”(`kRejected`)，并不冲突；这个返回值本质上只是用来回复是否还要继续流转击键事件；这种操作对特定场景有用，按实际需要使用；



### Translator(译码器)

- 接收待查的编码，产生候选项，无返回值

显然输入法除了要处理按键事件，还要做的一件非常重要的事情就是查表：汉字的编码排布信息输入法不可能凭空得出，需要依赖方案作者预先准备好 组织良好的 键值对数据，即表格、码表；translator的主要用途就是查这个表。

> 表，table，表格；有格式，有组织，有标注的许多数据或信息、被按照一定规则或逻辑放置的数据，这些数据放置、储存、查找、呈现的平面容器，可以称之为表；

为了方便管理或整理，我们可以将不同类型的字词分开在多个表中存放，这样也使得我们可以去除一部分我们不需要的字词表的存储与查询，节省性能与空间。例如，医学常用的词语可以单开一个词库，检测到特定用语环境下额外加载；平时可不加载，节省性能。

Rime可声明多个translator，但应当有一个主translator，这个translator有一些额外的用途；多个translator之间应当互不干扰，并且使用的效果也应当不受组件声明顺序影响；

可以为每一个translator指定优先级，高优先级translator产生的候选项会排在低优先级translator的前面（而不受任何组件列表中排序的影响）；但是多个translator之间的候选项不会交叉混排，一个translator产生的全部候选项会作为一个整体来排；（是这样吗，需要实践确认，存有一小点疑）

translator可以接收当前输入缓冲区的完整输入码作为输入、也可以接收一个由分段器流程切分好交付的输入码片段；

translator不需要返回值，在任何位置return一个“空”会提前中断其处理流程。

可以指定让Translaotr只处理指定的tag的segment

#### Candidate(候选项)

候选项是一个常用的数据类型，有这些属性：

- type：类型标记（只有固定的数个类型）
- text：候选词上屏内容，不可修改，只能在新建Candidate对象时设置
- preedit：输入码显示遮罩，当选框移动到候选项时可以临时替换输入码显示的内容
- start与end：标记候选项所属输入码范围
- comment：显示在上屏文字后面的提示内容
- quaility：候选项排序权重

#### Translator流程与Translation流

Rime是用cpp写的，有些设计套用了cpp的概念，比如“流”：Rime将Translator流程的输出候选项操作视作一个stream(流)，文档中有称为Translation流的；

一个流是单向流动的，不能“回流”，因此一旦将候选项“交付”给Rime引擎了，就不能再向Rime引擎要求退回了；但是可以在translator内部先开一个队列暂存，等到内部查完排好序了，再一齐向Rime引擎交付；

流类型也不能被索引或随机访问，只能通过迭代遍历的方式逐个读取，因此无法实现类似“在不获取第一个候选项的情况下获取第二个候选项”的功能；若想实现下标索引访问，需要手动维护记录被遍历的对象和次序计数；

> Filter迭代遍历处理的对象也是Translation流，只是内容上是所有Translator产生的候选项的而非单一个Translator的；因此接口也是相仿的。



### Filter(过滤器)

- 接收当前所有候选项，产生候选项，无返回值

检查每一个候选项，如果满足一些条件就滤除或修改掉；

#### Filter与Translator对比

filter与translator都可以产生候选项，没有返回值；但是两者区别在于，filter看到的是整一个候选项队列，是完整且有顺序的，是多个translator产生结果的合并；而translator则是只能去生成属于translator内部的候选项并提交，看不到其他translator的结果；filter只能通过按顺序遍历的方式，而不能通过任意下标的方式来处理候选项；

注意：

> filter虽然字面意思是过滤器，但是在Rime这里它的命名并不完全贴切：过滤器不光能过滤筛除候选项，还能新增、插入和修改。（甚至可以用这些能力来实现一个translator的基本功能）
>
> filter向Rime引擎交付候选项的接口与translator使用相同的接口，所以遵循相同的限制；当return时会中止整个Translation流
>
> filter和translator其实是被转换成一种叫generator(生成器) 的用于非阻塞并保留函数上下文地生成可迭代对象的概念，与协程有关。



### Segmentor(分段器)

- 逐个接收遍历所有Segment(片段)，可以向Segmentation插入、添加和减少Segment
- 可以遍历和修改Segment各项信息，可以获取输入码等信息
- 返回值表示分段处理结果（是否中止分段器流程）

尽管Segmentor是Compose流程中的第一道流程，但是它十分复杂，所以放到了最后讲；

要理解分段器，首先得理解Rime中的Segment是什么东西

> 由于不常用音码方案，我对Segment的概念也是一知半解，姑且抛砖引玉

#### Segment(分段,片段) 与 Segmentation

Segment主要是对输入码缓冲区复杂功能的一种抽象概念。它用于按一定的规则将输入码拆解，标定分段边界；统一拆解分段的接口（可以避免方案需要自己实现一套）。

Segmentor组件可以获取引擎当前的输入码缓冲区；以此为输入信息去增删改查Segmentation中的每个Segment；

Segment标定边界的具体实现形式为 记录每个分段字符串所属范围的 起始和结束的位置下标。

Segmentation，实现为`vector<T>`，一个可扩长且有序的对象容器（动态数组），你可以简单理解为给这些概念（的集合/列表/容器）起了个抽象的称呼。或者对于非计算机的人来说，一个清单列表（list），记录着很多个项目（item），可以供我们查看和修改

注意区分此Segmentation与输入码缓冲区；输入码缓冲区指的是完整的输入码字符串（librime-lua接口为`context.input`），没有被分割；而Segmentation是将输入码切分后的Segment列表（librime-lua接口为`context.composition:toSegmentation()`）；

> composition大概可以理解为Compose流程的合成计算结果，它与Segmentation关系十分密切；代码实现上，Composition类继承了Segmentation类，并增改了几个函数；

#### Segment的添加限制

- Segmentation不能有相同开头的Segment，在添加时会两者会自动合并为结尾更长的那个；长度相同时会合并其tags；
- 如果添加的Segment的开头位置不等于当前Segmentation末尾的Segment的开头，则此次添加将失败；

即是说：不得存在范围交叉 或 令输入码覆盖范围有空缺 的Segment：Segment必须是连续不间断地、按顺序地 覆盖完整输入码。

我们也可以简单说——Segmentors过程的目标，就是**将输入码切成连续的一段一段的Segment**，以便后续执行对每一个Segment分段都查询候选项的流程。

#### Segment的状态

对分段打上一个标记（为分段设置了一个属性），用以表明该分段的状态；状态类别包括待查询和已查定；并且Compose流程只会让Translator处理`待查询`状态的分段，跳过其他状态的分段；

Segment状态使得Segmentor组件有一个统一接口去判断是否分段已经被确认；也能控制Translator的查询分段范围，和engine上屏确认控制

#### Segment与候选项

Translator查找出的候选项“挂接”在某个Segment下，是属于某个Segment的，而不是无根依的；

> 候选项挂在Segment下，Segment挂在Segmentation下，Segmentation有一个继承类Composition，composition实例存储了合成结果，包括了Segmentation，所以在Compose流程之外获取候选项需要通过composition；Rime引擎也可以在内部存储composition对象来暂存__查询结果__状态（与之相对，context是_整个引擎_的状态，engine本身只有行为没有状态）

当选中一个候选项时，这个候选项首先被提交给Segment，而不是 直接上屏并通知词典更新词频记录等：Segment会记录选中的候选项（通过索引的方式），等到所有Segment都确认选择完成，才会上屏，并真正触发候选项选中相关的处理；如果在部分选中的中途退出了选择，则之前部分选中的候选项并不会触发相关选中更新事件

#### Segment与Compose流程

如果一个Segment都没有，则无法生成任何候选项，因为：Rime按照Compose流程，在Segmentors流程结束后，由于没有Segment可供Translator进行调用查找，所以不进入Translators流程（在for循环中遍历Segmentation由于迭代对象为空 循环体中的语句不会执行），即使Translator并不使用Segment的信息（例如简单地 直接获取输入码全码进行查询）

#### Segment的其他属性

可以给Segment打上tag，然后在Translator中去判断tag存在与否，选择性处理或忽略某些Segment；

可以给Segment加prompt提示信息，prompt会显示在输入码的后面一点；并击合成器chord_composoer就是利用了此功能在并击过程中显示实时指法合成结果提示；

#### Segment的实际使用场景

扯了很多概念上的东西，该举例一下Segment都实际用在什么地方了

1. Segment可以划分出不同类型的输入码（如数字、标点符号等），对输入码预先分解，不需要在码表中“擦屁股”

> 例如：想用“Bzhan”的编码得到“B站”，这个B就可以不需要送到拼音Translator中去查表，我们可以只允许小写26字母组合的“zhan”分段进入拼音Translator，而大写B则通过指定tag划给echo_translator直接生成原本的“B”的候选项；这样我们就不用在码表中增加一条“Bzhan”的编码项了，这样一道描述可以直接涵盖ABCDEFG到Z的所有站。
>
> 除了区分大写输入码，我们还可以对纯小写的编码进行模式匹配；当我们希望使用“bzhan”得到“b站”时，我们可以尝试匹配一个  “开头一个字符是小写字母a-z，后面是固定的zhan四个字母”  的输入码字符串样板，并对这种情况专门拆分成[a-z]和zhan，并将前者交给echo_translator，后者走正常拼音译码；这样可以实现不依赖大小写，而是做具体的模式匹配进行分段；这样我们就有了abcdef到z的站的候选。
>
> 符号的情况也与上述类同。

2. Segment可以与光标联动，选择拼音片段，分段选字，记录选中候选

> 例如：想输入“gougougou”编码得到“苟勾构”候选词，且这个新构的词码表里没有，所以我们需要逐拼音选字；移动光标至每个gou的音节末尾处，此时引擎会只使用光标前的部分作为“激活的”输入码，只使用这部分输入码执行Compose流程，而不是整段的输入码；然后依次找到并选中“苟” “勾” “构” 三个字，每选中一个字该Segment就从未选中状态变为了选中状态，同时选中候选项会触发上屏事件onSelect，engine处理该事件时会自动将光标位置移动到输入码末尾并再次触发Compose流程；此时之前选中的候选项会被暂存于Segment中，后续未完成编码重复前述流程并产生一个个暂存选中候选项的Segment；当所有Segment都处于选中状态时，Rime引擎就会自动上屏各Segment候选项的拼合文字，并处理相关候选项选中上屏事件（更新词频等操作）

总得来说是这两个要点：

- 切分输入码控制查码范围，提升查询命中率
- 对分段打tag标签，使Translator能判断tag，忽略不关心的分段
- 标记分段的选中状态、提供统一接口

> Segmentor其实不是很常开发插件自定义，lua_segmentor插件很不常见⋯⋯



## 总结

从Rime引擎核心的视角（而不是每个组件的）来说，执行流程大概是这样的：

- 操作系统传入击键事件，processors流程开始
- 每个processor按配置列出顺序执行，得到击键事件，可以处理操作，并且(我们假设有的processor)在过程中有组件触发了Compose流程（比如修改了context.input）；
- 跳转执行Compose流程，并执行segmentors、translators、filters流程：
	- segmentors每个组件按配置中列出顺序执行，可以增删改查分段表segmentation，返回值决定是否中断segmentors流程；
	- Segmentation中的每一个状态为kVoid空的分段都交由所有translators翻译；（状态不为空的分段都被跳过）
	- translators多个组件之间没有执行结果和状态的依赖关系，可以插入候选项，无返回值；
	- filters每个组件按配置中列出顺序执行，遍历获取候选项处理然后发回引擎，无返回值；
- 结束Compose流程，回到processor的调用处；继续执行该processor，处理完成processor返回一个处理结果；
- 由于多种可能原因完成了击键处理流程，向操作系统返回处理结果，结束。
