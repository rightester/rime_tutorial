# Rime组件的接口与执行流程

Rime是一个可以高度自定义的输入法引擎，这背后离不开它的 **组件化** 支持 —— 将功能抽离解耦成一个个小模块、组件(Component)，以便它们可以像拼积木一般被组合使用；

在已有了大量组件的情况下，我们先来看看Rime如何组织这些组件运行；



## 1、Rime的组件执行流程

下面给出几条规则：

1. 我们定义一个"触发合成"(Compose))的流程如下：

​	` (触发或调用Compose流程) -> Segmentors -> Translators -> Filters -> (结束Compose流程，返回调用处)`

​	这个流程可以被调用；

2. 然后我们有主流程如下：

​	`(Rime引擎接受系统平台的外部击键事件输入) -> Processors处理 -> (Rime引擎向外回复击键事件处理结果)`

​	其中：

​		每个processor在执行过程中，有许多操作可以导致"触发合成"

​		若“触发合成”，规则1的“Compose流程”会在该processor的 处理操作过程中 被调用执行；

​		processor也可以手动调用触发Compose流程；

3. 对于每一个组件类别下的**若干具体组件**，则是很直接地，按方案配置中 各组件**列出的顺序** **逐项**执行。

> 由上述规则可看出，“Compose流程”没有一个同Processors一般的，显式的 固定的 开始执行的入口，而是依赖于Processor的触发；Rime的组件执行流程实际上是以Processors的处理流程为主线的；



#todo 欠图一张，此处直接画出图来表现更合适



> 若一下没看明白，不着急，我们先把每个组件的介绍过一遍，然后把需求与限制梳理一番，最后再回过头来看这个流程，就能轻易弄懂了；

下面我们先来简单讨论下每个组件类型的用意；



## 2、四种组件类型

Rime的四种组件类型分别是：

- Processor （击键事件处理）
- Segmentor （输入码分段）
- Translator （输入码片段翻译）
- Filter （候选项处理与过滤）

### Processor（处理器）

- 接收击键事件参数，操作Rime引擎接口，返回击键事件处理结果

当你使用键盘在电脑上打字的时候，你按下的是键盘上的按键，这些按键的按下状态变化会通过通信协议和驱动程序 等 发送给操作系统；而操作系统接受到后，会 根据按键信息和系统配置 生成“击键事件”；

> 下面是对击键事件的一个大体的感受，用作整体模糊的了解，大致是以Windows系统为描述对象；可能存在许多不准确之处

#### 击键事件(Key Event)

我们期望击键事件应该被有次序地发送给当前窗口程序和想要接受这个击键事件的程序和软件等，保证程序接受到的顺序与你实际输入的顺序一致；

并且，“事件”应当只被处理一次，你的一波输入操作默认只应该让一个应用程序来处理；

> 这也符合我们的日常使用习惯和操作逻辑，比如按Alt+F4可以关闭程序，你按一下肯定意图是关闭一个，而不是一下子全部程序都关闭了；

一个程序会接受到很多并非自己所关注的击键事件；而程序需要自己读取判断击键事件，并做出处理：因为操作系统同时运行着多个程序/窗口界面，并不知道某个程序关注什么击键事件，只能将所有的击键事件都每个程序问一遍；

（此处应有一张图来更好描述）

操作系统其实还需要考虑 击键事件传递次序问题，先给谁后给谁；于是操作系统大概有个程序优先级排序，按照这个优先级的队列一个个地传递，通知程序产生了击键事件； 而被通知的应用也需要考虑到因为其他程序软件的存在，需要告诉操作系统 自己是否处置掉了这个击键事件，操作系统是否应该继续 对优先级队列中排在后面的程序 通知和传递击键事件；

因此，应用程序在处理完击键事件后，需要告诉操作系统自己的处置结果（通常用一个布尔值就足以表示返回结果了）

> 如此一套不很复杂的架构，足以完成多样的需求。举个例子：
> 我同时开着键盘热键重映射软件、输入法，并同时使用一个具有键盘快捷键交互功能的普通应用软件；
> （热键重映射的软件一般会通过系统接口将自己设置到优先级最高，保证自己可以先于一切其他程序接收到系统的击键事件，以确保完成热键重映射；而输入法一般是由操作系统保证在当前焦点窗口程序之前先取得击键事件；而前台/聚焦的窗口程序比后台的窗口更优先）
> 当我按下一组我想要交给窗口程序的快捷键时（比如Ctrl+C）：首先会被热键重映射软件接收到，它判断此组合键不在它需要处理的范围内，于是返回给操作系统一个“未处理，请继续传递”的信息；于是操作系统继续传递向下一个程序，到了输入法，输入法一看，这个键是组合修饰键，显然不是输入用的，于是也回复操作系统“未处理”；于是操作系统继续传递，终于到了前台窗口程序，前台窗口程序判断发现自己有相关快捷键的功能，于是开始执行相关功能，完成后向操作系统发出“已处理，不必再传递”的信息；于是操作系统认为这个击键事件已经被妥善处理，就停止了对该事件的传递，并准备处理下次的击键事件；

#### 类比到Processor

Rime的processors处理流程与前述的架构基本一致：

> Rime就是整个输入法内的“操作系统”，每一个processor就是“操作系统”中的一个个接收击键事件的应用程序；Rime引擎接受来自操作系统的击键事件后，按顺序轮询每一个processor；每个processor调用Rime接口处理，处理完成后返回处理结果；

每个processor主要只根据自己要实现的功能，来判断当前的击键事件如何处理：

- 当processor发现此击键事件是自己功能相关，需要自己处理时，该processor在处理完成后，向Rime返回`kAccepted`(接受)，表示此击键事件已被处理，于是Rime结束Processors流程，并向操作系统返回“已处理”；操作系统也完成和结束这次击键事件处理，不再向后续其他程序继续传递了；
- 当processor发现此击键事件是自己功能无关的，不需要干涉时，就向Rime返回`kNoop`(什么都不做)；此时Rime将该击键事件流转给下一个processor处理；直到流转给最后一个processor仍然返回`kNoop`时，也就意味着所有的processor都选择不处理该击键事件；则向操作系统返回“未处理”；操作系统继续将该击键事件通知其他优先级顺位程序处理；
- 当processor发现此击键事件为需要 为后续的processor排除 的击键事件时，可以选择向Rime引擎返回`kRejected`（弹出,拒绝）；此时Rime将中断该击键事件继续向后续的processor传递，并直接向操作系统返回“未处理”，以达到 中止Processors处理流程 的目的；此时操作系统也会继续将该击键事件通知给优先级队列处在后面的程序处理；

概括一下：

- 遇到processor“要拒绝”(`kRejected`) => Rime引擎报“不处理”

- 遇到processor“要接受”(`kAccepted`) => Rime引擎报“已处理”
- 所有processor都“不理睬”(`kNoop`) => Rime引擎报“不处理”

注意：

> “已处理” “未处理”、 “接受” “拒绝” “不理睬”，这些返回了的处理结果，与在处理过程中实际做没做处理、做了什么处理 并没有强制绑定关系：你完全可以对击键事件做了处理后，又返回“不理睬”(`kNoop`) 或 “拒绝”(`kRejected`)，并不冲突；这个返回值本质上只是用来回复是否还要继续流转击键事件；这种操作对特定场景有用，按实际需要使用；



### Translator（翻译器）

- 接收待查的编码，产生候选项，无返回值

显然输入法除了要处理按键事件，还要做的一件非常重要的事情就是查表：汉字的编码排布信息输入法不可能凭空得出，需要依赖方案作者预先准备好 组织良好的 键值对数据，即表格、码表；而查这个表就是translator的用途了（十分易懂）。

> 表，table，表格；有格式，有组织，有标注的许多数据或信息、被按照一定规则或逻辑放置的数据，这些数据放置、储存、查找、呈现的平面容器，可以称之为表；

为了方便管理或整理，我们可以将不同类型的字词分开在多个表中存放，这样也使得我们可以去除一部分我们不需要的字词表的存储与查询，节省性能与空间。例如，医学常用的词语可以单开一个词库，检测到特定用语环境下额外加载；平时可不加载，节省性能。

Rime可声明多个translator，但有一个主translator，这个translator有一些额外的用途；多个translator之间应当互不干扰，并且使用的效果也应当不受在组件列表中的声明顺序影响；

可以为每一个translator指定优先级，高优先级translator产生的候选项会排在低优先级translator的前面（而不受任何组件列表中排序的影响）；但是多个translator之间的候选项不会交叉混排，一个translator产生的全部候选项会作为一个整体来排；（是这样吗，需要实践确认，存有一小点疑）

translator可以接收当前输入缓冲区的完整输入码作为输入、也可以接收一个由分段器流程切分好交付的输入码片段；

translator不需要返回值，return一个“空”会中断其处理流程。

注意：

> 一旦将候选项“交付”给Rime引擎了，就不能再向Rime引擎要求退回了；一般在translator内部先开一个队列暂存，等到内部查完排好序了，再一齐向Rime引擎交付。



### Filter（过滤器）

- 接收当前所有候选项，产生候选项，无返回值

检查每一个候选项，如果满足一些条件就过滤或修改掉；

filter与translator都可以产生候选项，没有返回值；但是两者区别在于，filter看到的是整一个候选项队列，是完整且有一定顺序的，是多个translator产生结果的合并；而translator则是只能看到、生成和处理自己一个translator内部的候选项，看不到其他translator的结果；

注意：

> filter虽然字面意思是过滤器，但是在Rime这里它不光能过滤筛除候选项，还能新增、插入和修改。（你甚至可以用这些能力来实现一个translator的基本功能）
>
> filter向Rime引擎交付候选项的接口与translator遵循相同的限制，向Rime引擎“交付”后，候选项不能退回；因此，如果有多个候选项之间比较处理判断等功能的需求，可以与translator一样，开一处空间暂存所有候选项，等到处理完了再一齐向Rime引擎“交付”。
>
> 关于这个接口，我们后面再详谈，其实前面所说的还有些不准确的地方。filter和translator其实是被转换成一种叫generator（生成器）的用于非阻塞并保留函数上下文地生成可迭代对象的概念，与协程有关。



### Segmentor（分段器）

- 接收当前的输入码的所有Segment(片段)，可以向Segmentation插入、添加和减少Segment
- 可以遍历和修改Segment，及修改Segment状态等
- 返回分段处理结果（是否中止分段器流程）

要理解分段器，首先得理解Rime中的Segment是什么东西

> 由于我对音码方案研究有限，对Segment的概念是一知半解，姑且抛砖引玉

#### Segment(分段)

Segment主要是对输入码缓冲区复杂功能的一种抽象概念。它用于将用户的输入码拆解，标定分段边界。将拆解结果的接口在Rime的接口层面确定和统一（避免方案需要自己实现一套）。

Segmentor可以获取引擎当前的输入码缓冲区，也就是你都按下了什么键；以此为输入信息去增删改查Segmentation中的Segment；

Segmentation，Rime文档中一般称之为“Segment流”，如同Translation称之为“翻译流”类似的概念；其实现为`vector<T>`即一个可扩长和编列的对象容器（动态数组），你可以简单理解为给这些概念（的集合/列表/容器）起了个抽象的称呼。实际上我们就按数组来理解就好，或者对于非计算机的人来说，一个清单列表（list），记录着很多个项目（item），可以供我们查看和修改

注意区分此Segmentation与输入码缓冲区；我所指的输入码缓冲区是完整的输入码字符串（Rime接口为context.input），没有被分割；而Segmentation是将输入码切分后的Segment列表；

#### 成因？

为什么会有这么一个概念，为什么不直接把输入码完整送给翻译器查询就好了，要搞得这么麻烦？

首先是，我们输入码的可能性是多的，而码表，或拼音字表、词表或各种码表，不可能也不应该 通过记录被枚举出的所有可能候选项的方式实现，这样会浪费大量的存储空间用于存储低概率的候选项，查询性能也低下；另一方面我们也不可能在有限的空间下枚举出无限长度组合的可能性；我们希望Translator与码表，只做好一小件事情，就是给一个输入，查一个结果，而不必操心一个输入是否会存在于我待查的表中（毕竟如果没有查到结果，也就是未命中miss了，查询过程消耗的性能的完全浪费了，而Rime还算很注重性能）；我们通过前置步骤来确保我们交给Translator的查询编码输入，一定可以查到对应的结果；而这个前置步骤，Rime设计了Segmentors流程来完成。

假设我们想输入“你好”，使用完整拼音“nihao”；而我们的码表中没有“你好”这个词，只有“你”和“好”的单字，那么如果我们直接将nihao这段输入码送给Translator查询码表，是没有对应完全匹配的结果的；此时我们就可以先执行分段流程，通过一系列复杂的规则判断（具体来说是拼音拆分，区分声母韵母和对切分出的结果再筛选判断），我们可以将输入码拆分成“ni”和“hao”两个Segment。然后再让Translator分别对这两个Segment进行查询，就能得到“你” “好” 两个字，然后就能达到我们想要上屏“你好”这两个字的目标了；

实际上Segment概念还承载了实现更进一步的功能；我们上面提到的这个情况直接假设每个读音只有一个字（或者说，取了最高字频的每个单字的组合），但我们都知道一个读音下可能会有多个字，且每个音下最高频的字组合起来都不一定是一个有效的词，更不用说是否为我们实际所想输入的词了；

#### Segment的状态

现在，我们再考虑一种更高级的需求，选字组词，比如现在想要组出一个词，“苟勾构出发喽”，希望通过全拼 gou gou gou chufa lou打出；现在我们先将这串拼音直接输入到输入码缓冲区；然后按照Segmentors流程，其被拆分成了多个单字拼音片段；现在遇到了一个问题，输入法并不知道我们想要将gou编码选为哪个字，因为一个拼音会对应到大量汉字；而输入法也不能无脑地枚举出所有可能的项，屏幕上能显示的数量有限，不说硬件性能，光是数量太多就已经令用户看不过来了，而从中找出正确的候选项也更是大海捞针费时费力且低效；一种最简单也是最广泛使用的处理方式，是手动逐段拼音选字，一个个字地确定；单个字地查找，还是可以比较快找到的，因为用于组词的字通常也是高频常用字并不难找。

我们再考虑一种需求，在选字组词过程中，我们不小心点错了，想要回退该分段的选择；若是想回退最末尾的一个分段可以直接默认回退末尾；但是如果我们后知后觉地发现想要回退处在中间的分段的选择呢？于是，Rime做出了这样的设计：对分段打上一个标记，用以表明该分段的状态，包括待查询和已查定；并让Translator配合只处理待查询的分段；

通过Rime定义好Segment状态，我们可以有一个标准接口去判断是否所有的分段已经被确认，从而控制上屏等行为，和控制Translator的查询分段范围

#### Segmentation与光标

输入码缓冲区的光标位置与Segment的覆盖的输入码范围存在一定影响关系

#todo 待查源码分析其行为

#### Segmentation与tags

#todo 待补充

#### 注意事项

Segmentation不允许有相同开头的Segment，在添加时会两者会自动合并为结尾更长的那个；长度相同时会合并其tags；

如果添加的Segment的开头位置不等于当前Segmentation末尾的Segment的开头，则此次添加将失败；也就是说，不能存在交叉范围的Segment；Segment必须是连续且按顺序地，覆盖了完整输入码的。





## 总结

从Rime引擎核心的视角（而不是每个组件的）来说，执行流程大概是这样的：

- 操作系统传入击键事件，processors流程开始

- 每个processor按配置列出顺序执行，得到击键事件，可以处理操作，并且(我们假设有的processor)在过程中有组件触发了Compose流程（一般是写了context.input）；
- 跳转执行Compose流程，顺序执行segmentors，translators，filters：
	- segmentors每个组件按配置中列出顺序执行，可以增删改查分段表segmentation，返回值准定是否中断segmentors流程；
	- Segmentation中的每一个状态为kVoid空的分段都交由所有translators翻译；（状态不为空的分段都被跳过）
	- translators多个组件之间没有执行结果和状态的依赖关系，可以插入候选项，无返回值；
	- filters每个组件按配置中列出顺序执行，获取；
- 结束Compose流程，回到processor的调用处；继续执行该processor，处理完成processor返回一个处理结果；
- 由于多种可能原因完成了击键处理流程，向操作系统返回处理结果，结束。
